---
layout: section
color: amber-light
---

# アルゴリズムの計算量とオーダー記法

---
layout: top-title
color: amber-light
---

::title::

# アルゴリズムと計算量

::content::

- **アルゴリズム**: 問題を解くための計算の手続き
  - 同じ問題を解くにも様々なアルゴリズムが考えられますが, その中で最も効率的なものが望ましい
  - そこでアルゴリズムの効率性を定量的に測る尺度として**計算量** の概念を定義
  - 計算量にも様々なものがあり, 例えば時間計算量や空間計算量などがある


<v-clicks>

- **時間計算量** : サイズ$n$の任意の入力に対し, 計算が終わるまでにかかるステップ数

- **空間計算量** : サイズ$n$の任意の入力に対し, 計算が終わるまでに使用したメモリのサイズ

  - サイズ$n$の全ての入力について**最悪の**計算量を考える (最悪時計算量)

<div class="topic-box">
本講義では特に断りのない限り, 計算量と言えば最悪時時間計算量を指すものとし, 基本的な演算(加算や掛け算など)の回数によって測ることとする.
</div>

</v-clicks>


---
layout: top-title
color: amber-light
---

::title::

# 例: 1からnまでの総和を求める関数　{#example-sum-to-n}

::content::

<div class="question">

与えられた $n\in\Nat$ に対し, $1+2+\dots+n$ を出力せよ.

</div>

愚直に計算すると, 以下のコードになる:

```python
def sum_to_n(n):
	S=0
	for i in range(1,n+1):
		S=S+i
	return S
```

この関数は`S=0`と`S=S+i`のそれぞれで変数`S`の値を更新しています. 計算回数は`S=0`の箇所では1回, `S=S+i`は$n$回実行されるので, この関数の計算量は$n+1$となる.

---
layout: top-title
color: amber-light
---

::title::

# 例: 1からnまでの総和を求める関数

::content::

<div class="question">

与えられた $n\in\Nat$ に対し, $1+2+\dots+n$ を出力せよ.

</div>

等差数列の和の公式を使うと, 以下のように書ける:

```python
def sum_to_n(n):
	return n*(n+1)//2
```

`n*(n+1)//2`では, 1回の足し算, 1回の掛け算, 1回の割り算で計算するので, 計算回数は3となる. 例1と同じ値を計算しているが, $n$ が大きくなった時はこちらの方が計算回数が少ないので高速である. つまり, このアルゴリズムの方が前のものより効率的であるといえる.

<div class="remark">

実際のプログラムの実行時間は同じアルゴリズムであっても実装したときのプログラミング言語や実行環境によって変動しうるので, 「アルゴリズムの効率性」はこれらの外部的な要因を可能な限り排除した枠組みで議論する. 後で詳しく説明する.

</div>

---
layout: top-title
color: amber-light
---

::title::

# オーダー記法

::content::

<div class="topic-box">

アルゴリズムの効率性を議論するために不可欠な**関数のオーダー**の概念を説明する.

</div>

<v-clicks>

- 関数 $f\colon \Nat\to\Nat$ を考える. 
  - $f(n)$は, サイズ$n$の入力を受け取ったときのアルゴリズムの計算回数と思えばよい.
- アルゴリズムの効率性を議論する際は $n\to\infty$ における$f(n)$の**増加のスピード**を考える.
  - 例えば, $f(n)=n$よりも, $f'(n)=n^2$の方が速く増加する.
- 本質的にはアイデアの同じアルゴリズムであっても, 実際の計算回数は実装の細かい部分にも左右される.
  - このような細かい違いは無視したい (同じアイデアのアルゴリズムは同じ計算量として評価したい)
  - そこで, $f(n)$の増加スピードにおいて, **定数倍は無視**する.
    - 例えば, $f(n)=2n^2$ と $f(n)=3n^2+2n$ は「同程度の」計算量とする

</v-clicks>

---
layout: top-title
color: amber-light
---

::title::

# オーダー記法

::content::

<div class="definition">

関数の支配項 (最も大きい部分) を抜き出し, その係数を1としたものをその関数の**オーダー**と呼び, 関数$f(n)$のオーダーが$g(n)$であるとき, $f(n)=O(G(n))$ と書く.

</div>

<v-clicks>

- 例1: $f(n)=3n^2+5n+2$ の支配項は $3n^2$ であり, 係数を$1$とすると $n^2$ になる.
  - よって$3n^2+5n+2$ は $n^2$ のオーダーであるといい, $3n^2+5n+2=O(n^2)$と書く.

- 例2: $f(n)=\sqrt{n} + \log n$ の支配項は $\sqrt{n}$ なので, $f(n)=O(\sqrt{n})$ である.



<div class="remark">

「支配項」の定義が曖昧なので, この定義は厳密なものではない. 厳密なオーダーの定義は次ページで紹介

</div>

</v-clicks>

---
layout: top-title
color: amber-light
---
::title::

# オーダー記法

::content::

厳密には, $f(n)=O(g(n))$の定義は以下のようになる:

<div class="definition">

関数 $f\colon\Nat\to\Nat$ と $g\colon\Nat\to\Nat$ に対し, $f(n)=O(g(n))$ であるとは, ある定数$C>0$と$N\in\Nat$が存在し, 任意の$n\ge N$に対して $f(n) \le C\cdot g(n)$ が成り立つことをいう.

</div>

<v-clicks>

- 直感: どんなに大きな $n$ を考えても, $f(n)$ は $g(n)$ の**定数倍** で上から抑えられる
  - **定数**: $n$に依存しない固**定**された**数**
  - $f(n)$の増加スピードが$g(n)$の増加スピードよりも**速くならない**ことを意味する
  - 小さい $n$ ($n<N$) での大小関係は無視する (十分大きな$n$での振る舞いを考える)

<div class="question">

厳密な定義を使って$3n^2+5n+2=O(n^2)$が成り立つことを証明せよ.

</div>

</v-clicks>

---
layout: top-title
color: amber-light
---
::title::

# 例. 1からnまでの和を求める関数

::content::

```python
def sum_to_n(n):
	S=0
	for i in range(n):
		S=S+i
	return S
```

- この関数の計算量は $n + 1$ である
  - 2行目の代入操作は1回
  - 4行目の`S=S+i`は$n$回実行される
  
- よって, 計算量のオーダーは $O(n)$ である.


---
layout: top-title
color: amber-light
---

::title::

# 例. 1からnまでの和を求める関数

::content::

```python
def sum_to_n(n):
	return n*(n+1)//2
```

- この関数の計算量は $3$ である
- オーダーで表すと $O(1)$ である ($g(n)=1$という関数も考える)

<v-clicks>

- つまり, 上記のコードの計算量は $n$ に依存しない定数で上から抑えられることになる. 本当にそのようなことがありえるのだろうか?

<div class="remark">

ここでは, 計算量を「演算の回数」によって定義していた. しかし, 実際にはコンピュータの1回の演算は**一桁同士の数字の加算や乗算**を実行できるに過ぎない. 従って, **加算や乗算などの演算は少なくともその桁数に比例した時間がかかる** (足し算の筆算を考えてると分かりやすい).
$n$の桁数は $\lceil\log_{10} n\rceil$ であるから, 実際には上記のプログラムの計算時間は$O(\log n)$となる.

なお, 厳密な計算量の定義をするには**オートマトン**や**チューリング機械**の知識が必要になってしまい, この講義の範囲から大きく逸脱してしまうのでここでは省略する.

</div>

</v-clicks>

---
layout: top-title
color: amber-light
---

::title::

# 例. 行列積の計算

::content::

二つの$n\times n$行列$A,B$が与えられたとき, $A\cdot B$を返す以下の関数を考える:

```python
def matrix_mult(A, B):
  n = len(A)
  C = [[0]*n for _ in range(n)]
  for i in range(n):
    for j in range(n):
      for k in range(n):
        C[i][j] += A[i][k] * B[k][j]
  return C
```

上のコードでは行列積を定義通りに計算している:
$$
  (AB)_{i,j} = \sum_{k=1}^n A_{i,k}\cdot B_{k,j}
$$

<div class="question">

上記のコードの計算量のオーダーはいくつか? 数値の桁数は無視し, 演算の回数だけ考えればよい.

</div>
